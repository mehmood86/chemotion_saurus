"use strict";(self.webpackChunkchemotion_saurus=self.webpackChunkchemotion_saurus||[]).push([[4118],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),d=r,_=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return t?a.createElement(_,o(o({ref:n},c),{},{components:t})):a.createElement(_,o({ref:n},c))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1037:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={id:"performance",title:"Investigating performance",sidebar_label:"Investigating performance",slug:"performance"},o=void 0,s={unversionedId:"eln/development/performance",id:"eln/development/performance",title:"Investigating performance",description:"Poor performance is bad for user experience.",source:"@site/docs/eln/development/performance.mdx",sourceDirName:"eln/development",slug:"/eln/development/performance",permalink:"/chemotionsaurus/docs/eln/development/performance",draft:!1,editUrl:"https://github.com/ComPlat/chemotion_saurus/edit/master/docs/eln/development/performance.mdx",tags:[],version:"current",lastUpdatedBy:"Danny Truong",lastUpdatedAt:1663309693,formattedLastUpdatedAt:"Sep 16, 2022",frontMatter:{id:"performance",title:"Investigating performance",sidebar_label:"Investigating performance",slug:"performance"},sidebar:"elnSidebar",previous:{title:"Continuous integration",permalink:"/chemotionsaurus/docs/eln/development/ci"},next:{title:"Configuration",permalink:"/chemotionsaurus/docs/category/configuration"}},l={},p=[],c={toc:p};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Poor performance is bad for user experience.\nIf you notice that parts of the ELN don't perform as well as you'd like,\nit might be helpful to find out ",(0,r.kt)("em",{parentName:"p"},"why")," that is the case, and how you could improve it.\nThis chapter provides some guidance on how to investigate performance."),(0,r.kt)("p",null,"We follow the example of investigating the performance of creating a reaction.\nWe'll only deal with the backend for the moment, meaning the performance investigation will be limited to Ruby."),(0,r.kt)("p",null,"For a good general primer on performance investigations have a look at ",(0,r.kt)("a",{parentName:"p",href:"https://youtu.be/XL51vf-XBTs"},"https://youtu.be/XL51vf-XBTs"),"."),(0,r.kt)("h1",{id:"isolating-the-issue"},"Isolating the issue"),(0,r.kt)("p",null,"Once you've identified a performance issue (e.g., creating a reaction is slow), you need a quick, repeatable way to reproduce it.\nThis is why we start by setting up an ",(0,r.kt)("inlineCode",{parentName:"p"},"rspec")," test (",(0,r.kt)("a",{parentName:"p",href:"https://rspec.info"},"https://rspec.info"),") to isolate the issue."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:'title="spec/api/reaction_api_performance_spec.rb"',title:'"spec/api/reaction_api_performance_spec.rb"'},"# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe 'Reaction API POST' do\n  let(:user) { create(:user) }\n  let(:root_container) { create(:root_container) }\n  let(:collection) { Collection.create!(label: 'Collection', user: user) }\n  let(:reaction) { create(:reaction, name: 'Reaction', collections: [collection]) }\n  let(:sample) { create(:sample, name: 'Sample', container: FactoryBot.create(:container)) }\n  let(:molfile) { File.read(Rails.root + 'spec/fixtures/test_2.mol') }\n  let(:params) do\n    {\n      'name' => 'r001',\n      'collection_id' => collection.id,\n      'container' => root_container,\n      'materials' => {\n        'starting_materials' => [\n          'id' => sample.id,\n          'name' => 'starting_material',\n          'target_amount_unit' => 'mg',\n          'target_amount_value' => 75.09596,\n          'equivalent' => 1,\n          'reference' => false,\n          'is_new' => false,\n          'molfile' => molfile,\n          'container' => root_container\n        ],\n        'reactants' => [\n          'target_amount_unit' => 'mg',\n          'target_amount_value' => 86.09596,\n          'equivalent' => 2,\n          'reference' => false,\n          'is_new' => true,\n          'molfile' => molfile,\n          'container' => root_container,\n          'parent_id' => sample.id # gets named after parent, hence no name specified\n        ],\n        'products' => [\n          'name' => 'product',\n          'target_amount_unit' => 'mg',\n          'target_amount_value' => 99.08304,\n          'equivalent' => 5.5,\n          'reference' => false,\n          'is_new' => true,\n          'molfile' => molfile,\n          'container' => root_container\n        ],\n        'solvents' => [\n          'name' => 'solvent',\n          'target_amount_unit' => 'mg',\n          'target_amount_value' => 76.09596,\n          'equivalent' => 1,\n          'reference' => true,\n          'is_new' => true,\n          'molfile' => molfile,\n          'container' => root_container\n        ]\n      }\n    }\n  end\n\n  before do\n    allow_any_instance_of(WardenAuthentication).to receive(:current_user)\n      .and_return(user)\n    ReactionsStartingMaterialSample.create!(\n      reaction: reaction, sample: sample, reference: true, equivalent: 1\n    )\n  end\n\n\n  it 'creates reaction in under one second', :profile do\n    post '/api/v1/reactions', params: params, as: :json\n  end\nend\n")),(0,r.kt)("h1",{id:"benchmarking"},"Benchmarking"),(0,r.kt)("p",null,"The goal of a performance investigation is to eventually improve performance.\nIn order for those improvements to be objective, we need a baseline:\nHow long does it take (on your system) to create a reaction? If you have that number,\nyou have a target for your improvements.\nYou can quantifying performance by using a benchmarking tool.\nWe use ",(0,r.kt)("inlineCode",{parentName:"p"},"rspec-benchmark")," (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/piotrmurach/rspec-benchmark"},"https://github.com/piotrmurach/rspec-benchmark"),") to benchmark the ",(0,r.kt)("inlineCode",{parentName:"p"},"rspec")," test we set up earlier.\nAfter installing the framework (",(0,r.kt)("inlineCode",{parentName:"p"},"bundle add rspec-benchmark"),") you can make it available as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:'title="spec/spec_helper.rb"',title:'"spec/spec_helper.rb"'},"require 'rspec-benchmark'\n\nRSpec.configure do |config|\n  config.include RSpec::Benchmark::Matchers\nend\n")),(0,r.kt)("p",null,"You're now ready to include ",(0,r.kt)("inlineCode",{parentName:"p"},"rspec-benchmark")," syntax / DSL in you test (for details head over to the ",(0,r.kt)("inlineCode",{parentName:"p"},"rspec-benchmark")," docs):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:'title="spec/api/reaction_api_performance_spec.rb"',title:'"spec/api/reaction_api_performance_spec.rb"'},"it 'creates reaction in under one second' do\n  expect { post '/api/v1/reactions', params: params, as: :json }.to perform_under(1000).ms.times.sample(100).times\nend\n")),(0,r.kt)("p",null,"We extended the test such that it's executed 100 times (in order to get statistically meaningful results),\nand we expect the creation of a reaction to be done in under one second.\nWhen running the test, we get the following report."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"reaction API\n  creates reaction in under one second (FAILED - 1)\n\nFailures:\n\n  1) reaction API creates reaction in under one second\n     Failure/Error: expect { post '/api/v1/reactions', params: params, as: :json }.to perform_under(1000).ms.warmup(1).times.sample(100).times\n       expected block to perform under 1 sec, but performed above 2.31 sec (\xb1 452 ms)\n")),(0,r.kt)("p",null,"We now have an impression of how long it takes on average to create a reaction on your system.\nYou can use this baseline to start improving the performance."),(0,r.kt)("h1",{id:"profiling"},"Profiling"),(0,r.kt)("p",null,"In order to improve performance, we now need to identify hot spots in the code that lend themselves for optimization.\nProfiling can help finding these hot spots by breaking down how much time (or CPU cycles) a program spends in each of its components (e.g., methods).\nWe can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"stackprof")," (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/tmm1/stackprof"},"https://github.com/tmm1/stackprof"),") gem to profile our ",(0,r.kt)("inlineCode",{parentName:"p"},"rspec")," test.\nAfter installing the gem with ",(0,r.kt)("inlineCode",{parentName:"p"},"bundle add stackprof")," we need to configure it as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:'title="spec/spec_helper.rb"',title:'"spec/spec_helper.rb"'},"require 'stackprof'\n\nRSpec.configure do |config|\n  config.around do |example|\n    if example.metadata[:profile]\n      StackProf.run(mode: :wall, interval: 250000, raw: true, out: 'tmp/stackprof.dump') do\n        example.run\n      end\n    else\n      example.run\n    end\n  end\nend\n")),(0,r.kt)("p",null,"We're specifying that we want to sample the call stack every 250000 microseconds and that we want to write the profiling results to ",(0,r.kt)("inlineCode",{parentName:"p"},"tmp/stackprof.dump"),".\nFinally, we can mark our test for profiling by adding the ",(0,r.kt)("inlineCode",{parentName:"p"},":profile")," keyword."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby",metastring:'title="spec/api/reaction_api_performance_spec.rb"',title:'"spec/api/reaction_api_performance_spec.rb"'},"it 'creates reaction in under one second', :profile do\n  expect { post '/api/v1/reactions', params: params, as: :json }.to perform_under(1000).ms.times.sample(100).times\nend\n")),(0,r.kt)("p",null,"After running the test, we can visualize the profiling results by having ",(0,r.kt)("inlineCode",{parentName:"p"},"stackprof")," construct an interactive flamegraph that you can inspect in your browser."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bundle exec stackprof --d3-flamegraph tmp/stackprof.dump > tmp/stackprof-flamegraph.html\n")),(0,r.kt)("p",null,"Have a look at the following resources for details on how to read flamegraphs:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://youtu.be/6uKZXIwd6M0"},"https://youtu.be/6uKZXIwd6M0")," (5:20-13:00)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.brendangregg.com/flamegraphs.html"},"https://www.brendangregg.com/flamegraphs.html"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"stackprof")," can also break down how much time the tests spends on each line of a function call.\nThis can help zooming in on hot spots."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bundle exec stackprof tmp/stackprof-wall.dump --method ReactionHelpers#update_materials_for_reaction\n")),(0,r.kt)("p",null,"The result looks as follows. For example, it looks like the call to ",(0,r.kt)("inlineCode",{parentName:"p"},".save!")," on line 163 might be a good candidate for further investigation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ReactionHelpers#update_materials_for_reaction (/workspace/chemotion/app/api/chemotion/reaction_api.rb:48)\n  samples:     0 self (0.0%)  /    568 total (54.9%)\n  callers:\n    1038  (  182.7%)  ReactionHelpers#update_materials_for_reaction\n     568  (  100.0%)  block (2 levels) in <class:ReactionAPI>\n     520  (   91.5%)  ActiveRecord::ConnectionAdapters::DatabaseStatements#transaction\n  callees (568 total):\n    1038  (  182.7%)  ReactionHelpers#update_materials_for_reaction\n     520  (   91.5%)  ActiveRecord::Transactions::ClassMethods#transaction\n     411  (   72.4%)  ActiveRecord::Suppressor#save!\n      59  (   10.4%)  ActiveRecord::Persistence::ClassMethods#create!\n      49  (    8.6%)  Sample#create_subsample\n      10  (    1.8%)  ActiveRecord::Associations::CollectionProxy#<<\n      10  (    1.8%)  ContainerHelpers#update_datamodel\n       9  (    1.6%)  Sample::GeneratedAssociationMethods#container=\n       7  (    1.2%)  ActiveRecord::Persistence#update!\n       3  (    0.5%)  ActiveRecord::Core::ClassMethods#find_by\n       3  (    0.5%)  ActiveRecord::Core::ClassMethods#find\n       2  (    0.4%)  ActiveRecord::Inheritance::ClassMethods#new\n       1  (    0.2%)  Sample::GeneratedAssociationMethods#collections\n       1  (    0.2%)  ActiveRecord::Relation#destroy_all\n       1  (    0.2%)  ActiveRecord::Delegation#[]\n       1  (    0.2%)  ActiveRecord::Aggregations#reload\n       1  (    0.2%)  Segmentable#save_segments\n  code:\n                                  |    48  |   def update_materials_for_reaction(reaction, material_attributes, current_user)\n                                  |    49  |     collections = reaction.collections\n                                  |    50  |     materials = OpenStruct.new(material_attributes)\n                                  |    51  |     materials = {\n                                  |    52  |       starting_material: Array(material_attributes['starting_materials']).map { |m| OSample.new(m) },\n                                  |    53  |       reactant: Array(material_attributes['reactants']).map { |m| OSample.new(m) },\n                                  |    54  |       solvent: Array(material_attributes['solvents']).map { |m| OSample.new(m) },\n                                  |    55  |       purification_solvent: Array(material_attributes['purification_solvents']).map { |m| OSample.new(m) },\n                                  |    56  |       product: Array(material_attributes['products']).map { |m| OSample.new(m) }\n                                  |    57  |     }\n  520   (50.3%)                   |    58  |     ActiveRecord::Base.transaction do\n                                  |    59  |       included_sample_ids = []\n  519   (50.2%)                   |    60  |       materials.each do |material_group, samples|\n                                  |    61  |         fixed_label = material_group =~ /solvents?|reactants?/ && $&\n                                  |    62  |         reactions_sample_klass = \"Reactions#{material_group.to_s.camelize}Sample\"\n  519   (50.2%)                   |    63  |         samples.each_with_index do |sample, idx|\n                                  |    64  |           sample.position = idx if sample.position.nil?\n                                  |    65  |           sample.reference = false if material_group === 'solvent' && sample.reference == true\n                                  |    66  |           # create new subsample\n                                  |    67  |           if sample.is_new\n                                  |    68  |             if sample.parent_id && material_group != 'products'\n    1    (0.1%)                   |    69  |               parent_sample = Sample.find(sample.parent_id)\n                                  |    70  |\n                                  |    71  |               # TODO: extract subsample method\n   49    (4.7%)                   |    72  |               subsample = parent_sample.create_subsample(current_user, collections, true)\n                                  |    73  |\n                                  |    74  |               # Use 'reactant' or 'solvent' as short_label\n                                  |    75  |               subsample.short_label = fixed_label if fixed_label\n                                  |    76  |\n                                  |    77  |               subsample.target_amount_value = sample.target_amount_value\n                                  |    78  |               subsample.target_amount_unit = sample.target_amount_unit\n                                  |    79  |               subsample.real_amount_value = sample.real_amount_value\n                                  |    80  |               subsample.real_amount_unit = sample.real_amount_unit\n                                  |    81  |               subsample.metrics = sample.metrics\n                                  |    82  |\n                                  |    83  |               # add new data container\n                                  |    84  |               # subsample.container = create_root_container\n    3    (0.3%)                   |    85  |               subsample.container = update_datamodel(sample.container) if sample.container\n   18    (1.7%)                   |    86  |               subsample.save!\n    1    (0.1%)                   |    87  |               subsample.reload\n    1    (0.1%)                   |    88  |               subsample.save_segments(segments: parent_sample.segments, current_user_id: current_user.id)\n                                  |    89  |\n                                  |    90  |               included_sample_ids << subsample.id\n                                  |    91  |               s_id = subsample.id\n                                  |    92  |             # create new sample\n                                  |    93  |             else\n                                  |    94  |               attributes = sample.to_h.except(\n                                  |    95  |                 :id, :is_new, :is_split, :reference, :equivalent, :position,\n                                  |    96  |                 :type, :molecule, :collection_id, :short_label, :waste, :show_label, :coefficient, :user_labels,\n                                  |    97  |                 :boiling_point_lowerbound, :boiling_point_upperbound,\n                                  |    98  |                 :melting_point_lowerbound, :melting_point_upperbound, :segments\n                                  |    99  |               ).merge(created_by: current_user.id,\n                                  |   100  |                       boiling_point: rangebound(sample.boiling_point_lowerbound, sample.boiling_point_upperbound),\n                                  |   101  |                       melting_point: rangebound(sample.melting_point_lowerbound, sample.melting_point_upperbound))\n                                  |   102  |\n                                  |   103  |               # update attributes[:name] for a copied reaction\n                                  |   104  |               if (reaction.name || '').include?('Copy') && attributes[:name].present?\n                                  |   105  |                 named_by_reaction = \"#{reaction.short_label}\"\n                                  |   106  |                 named_by_reaction += \"-#{attributes[:name].split('-').last}\"\n                                  |   107  |                 attributes.merge!(name: named_by_reaction)\n                                  |   108  |               end\n                                  |   109  |\n                                  |   110  |               container_info = attributes[:container]\n                                  |   111  |               attributes.delete(:container)\n                                  |   112  |               attributes.delete(:segments)\n    2    (0.2%)                   |   113  |               new_sample = Sample.new(\n                                  |   114  |                 attributes\n                                  |   115  |               )\n                                  |   116  |\n                                  |   117  |               # Use 'reactant' or 'solvent' as short_label\n                                  |   118  |               new_sample.short_label = fixed_label if fixed_label\n                                  |   119  |\n                                  |   120  |               # add new data container\n    6    (0.6%)                   |   121  |               new_sample.container = update_datamodel(container_info)\n                                  |   122  |\n   11    (1.1%)                   |   123  |               new_sample.collections << collections\n  106   (10.3%)                   |   124  |               new_sample.save!\n                                  |   125  |               new_sample.save_segments(segments: sample.segments, current_user_id: current_user.id)\n                                  |   126  |               included_sample_ids << new_sample.id\n                                  |   127  |               s_id = new_sample.id\n                                  |   128  |             end\n   58    (5.6%)                   |   129  |             ReactionsSample.create!(\n                                  |   130  |               sample_id: s_id,\n                                  |   131  |               reaction_id: reaction.id,\n                                  |   132  |               equivalent: sample.equivalent,\n                                  |   133  |               reference: sample.reference,\n                                  |   134  |               show_label: sample.show_label,\n                                  |   135  |               waste: sample.waste,\n                                  |   136  |               coefficient: sample.coefficient,\n                                  |   137  |               position: sample.position,\n                                  |   138  |               type: reactions_sample_klass\n                                  |   139  |             ) if s_id\n                                  |   140  |             s_id = nil\n                                  |   141  |           # update the existing sample\n                                  |   142  |           else\n    2    (0.2%)                   |   143  |             existing_sample = Sample.find(sample.id)\n                                  |   144  |\n                                  |   145  |             existing_sample.target_amount_value = sample.target_amount_value\n                                  |   146  |             existing_sample.target_amount_unit = sample.target_amount_unit\n                                  |   147  |             existing_sample.real_amount_value = sample.real_amount_value\n                                  |   148  |             existing_sample.real_amount_unit = sample.real_amount_unit\n                                  |   149  |             existing_sample.metrics = sample.metrics\n                                  |   150  |             existing_sample.external_label = sample.external_label if sample.external_label\n                                  |   151  |             existing_sample.short_label = sample.short_label if sample.short_label\n                                  |   152  |             existing_sample.short_label = fixed_label if fixed_label\n                                  |   153  |             existing_sample.name = sample.name if sample.name\n                                  |   154  |\n    1    (0.1%)                   |   155  |             if r = existing_sample.residues[0]\n                                  |   156  |               r.assign_attributes sample.residues_attributes[0]\n                                  |   157  |             end\n                                  |   158  |\n                                  |   159  |             if sample.container\n   10    (1.0%)                   |   160  |               existing_sample.container = update_datamodel(sample.container)\n                                  |   161  |             end\n                                  |   162  |\n  239   (23.1%)                   |   163  |             existing_sample.save!\n                                  |   164  |             existing_sample.save_segments(segments: sample.segments, current_user_id: current_user.id) if sample.segments\n                                  |   165  |\n                                  |   166  |             included_sample_ids << existing_sample.id\n                                  |   167  |\n    3    (0.3%)                   |   168  |             existing_association = ReactionsSample.find_by(sample_id: sample.id)\n                                  |   169  |\n                                  |   170  |             # update existing associations\n                                  |   171  |             if existing_association\n    7    (0.7%)                   |   172  |               existing_association.update_attributes!(\n                                  |   173  |                 reaction_id: reaction.id,\n                                  |   174  |                 equivalent: sample.equivalent,\n                                  |   175  |                 reference: sample.reference,\n                                  |   176  |                 show_label: sample.show_label,\n                                  |   177  |                 waste: sample.waste,\n                                  |   178  |                 coefficient: sample.coefficient,\n                                  |   179  |                 position: sample.position,\n                                  |   180  |                 type: reactions_sample_klass\n                                  |   181  |               )\n                                  |   182  |             # sample was moved to other materialgroup\n                                  |   183  |             else\n                                  |   184  |               # create a new association\n    1    (0.1%)                   |   185  |               ReactionsSample.create!(\n                                  |   186  |                 sample_id: sample.id,\n                                  |   187  |                 reaction_id: reaction.id,\n                                  |   188  |                 equivalent: sample.equivalent,\n                                  |   189  |                 reference: sample.reference,\n                                  |   190  |                 show_label: sample.show_label,\n                                  |   191  |                 waste: sample.waste,\n                                  |   192  |                 coefficient: sample.coefficient,\n                                  |   193  |                 position: sample.position,\n                                  |   194  |                 type: reactions_sample_klass\n                                  |   195  |               )\n                                  |   196  |             end\n                                  |   197  |           end\n                                  |   198  |         end\n                                  |   199  |       end\n                                  |   200  |\n                                  |   201  |       # delete all samples not anymore in one of the groups\n                                  |   202  |\n                                  |   203  |       current_sample_ids = reaction.reactions_samples.pluck(:sample_id)\n                                  |   204  |       deleted_sample_ids = current_sample_ids - included_sample_ids\n    1    (0.1%)                   |   205  |       Sample.where(id: deleted_sample_ids).destroy_all\n                                  |   206  |\n                                  |   207  |       # for testing\n                                  |   208  |       # raise ActiveRecord::Rollback\n                                  |   209  |     end\n                                  |   210  |\n                                  |   211  |     # to update the SVG\n                                  |   212  |     reaction.reload\n   48    (4.6%)                   |   213  |     reaction.save!\n                                  |   214  |   end\n")))}m.isMDXComponent=!0}}]);